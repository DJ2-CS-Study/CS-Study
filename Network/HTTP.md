# HTTP

[TOC]

## 모든 것이 HTTP

### HTTP의 시작

HTTP는 **H**yper **T**ext **T**ransfer **P**rotocol의 약자입니다. HTTP는 하이퍼 텍스트를 전달하기 위한 프로토콜 즉, HTML을 전송하기 위한 프로토콜로 시작되었습니다.



### 이제는 모든 것이 HTTP

하지만 현재는 HTTP 메시지로 거의 모든 형태의 데이터 전송이 가능합니다. 아래 보이는 형식을 모두 전송할 수 있습니다.

- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML(API)

요즘은 서버 간의 데이터를 주고 받을 때도 대부분 HTTP를 사용할 정도입니다. 지금은 HTTP 시대라고 해도 과언이 아닙니다. 



### HTTP의 역사

- HTTP/0.9 (1991): GET 메서드만 지원, HTTP 헤더 X
- HTTP/1.0 (1996): 메서드, 헤더 추가
- **HTTP/1.1 (1997): 가장 많이 사용, 우리에게 가장 중요한 버전**
  - RFC2068 (1997) => RFC2616 (1999) => RFC7230~7235 (2014)
  - 현재 인터넷 자료나 서적은 1999년에 나온 RFC2616 스펙을 설명한 것들이 많습니다.
  - RFC2616은 폐기되었으므로 최신 버전인 RFC 723X 버전을 알고 있는 것이 좋습니다. 관련 내용은 HTTP 헤더 부분에서 나올 예정입니다.
  - 1.1 버전에서 대부분의 기능이 구현되었고 2, 3 버전은 성능 개선에 초점이 맞추어져 있기 때문에 1.1을 이해하고 나면 추후에 2, 3을 이해하는 것은 어렵지 않습니다..
- HTTP/2 (2015): 성능 개선
- HTTP/3 (진행중): TCP 대신 UDP 사용, 성능 개선



### 기반 프로토콜

- TCP: HTTP/1.1, HTTP/2
- UDP: HTTP/3
- 현재 HTTP/1.1 주로 사용
  - HTTP/2, HTTP/3도 점점 증가



### HTTP 버전 확인

- 개발자 도구 > Network > 우클릭 > 프로토콜 클릭
- 다음과 같이 표시됩니다.
  - HTTP/1.1 => http/1.1
  - HTTP/2 => h2
  - HTTP/3 => h3

|                      프로토콜 확인 방법                      |
| :----------------------------------------------------------: |
| <img src="./HTTP.assets/protocol.gif" style="width: 1000px;"> |



### HTTP 특징

#### 클라이언트 - 서버 구조

- 클라이언트는 서버에 요청을 보내고, 응답을 기다립니다.
- 서버는 요청에 대한 결과를 만들어서 응답합니다.
- 현재는 너무나 당연한 방법이지만, 클라이언트와 서버의 구분이 없던 때도 있었다고 합니다!



#### 무상태 프로토콜(Stateless)

HTTP는 서버가 클라이언트의 상태를 보존하지 않기 때문에 무상태 프로토콜이라고 부릅니다. 무상태 프로토콜은 아래와 같은 장단점이 있는데 왜 이러한 장단점이 생기는지 알아보겠습니다.

- 장점: 서버의 확장성이 높습니다.(스케일 아웃)
- 단점: 클라이언트가 전송해야 할 데이터가 비교적 많습니다.



##### Stateful VS Stateless

우선 Stateful(상태 유지)와 Stateless(무상태)의 차이를 이해해야 합니다. 클라이언트 - 서버 간의 요청을 노트북을 구매하려는 고객(클라이언트)과 점원(서버)로 비유해보겠습니다.

먼저 **Stateful(상태 유지)한 방식**입니다.

| Stateful(상태 유지)                                          |
| :----------------------------------------------------------- |
| - 고객: 이 **노트북** 얼마인가요?<br />- 점원: 100만원입니다. **(노트북 상태 유지)**<br /><br />- 고객: **2개** 구매하겠습니다.<br />- 점원: 200만원입니다. **신용카드, 현금** 중에 어떤 걸로 구매하시겠어요? **(노트북, 2개 상태 유지)**<br /><br />- 고객: **신용카드**로 구매하겠습니다.<br />- 점원: 200만원 결제 완료되었습니다. **(노트북 2개, 신용카드 상태 유지)** |

2번째 대화에서, 고객은 **2개**를 구매하겠다고 말합니다. 무엇을 2개 사는지는 말하지 않았죠. 하지만 점원은 이전 대화(요청)에서 노트북 상태를 유지하고 있기 때문에 노트북 2개를 구매한다는 것을 알고 200만원이라는 결제 금액을 응답할 수 있습니다. **즉, 서버가 상태를 유지하는 것이죠.**

이렇게 보면 상태 유지 방식도 문제가 없어보입니다. **하지만 중간에 점원(서버)이 바뀐다면 어떻게 될까요?**

| Stateful(상태 유지) - 점원이 바뀐다면?                       |
| :----------------------------------------------------------- |
| - 고객: 이 **노트북** 얼마인가요?<br />- **점원 A**: 100만원입니다. **(노트북 상태 유지)**<br /><br />- 고객: **2개** 구매하겠습니다.<br />- **점원 B**: 어떤걸 2개 구매하시는거죠..? |

점원(서버) 측에서 상태 유지를 하고 있기 때문에 새로운 점원이 투입되면 고객은 처음부터 결제 과정을 반복해야 하는 문제가 발생합니다. 아니면 점원 A가 떠나기 전, 점원 B에게 상태를 넘겨주는 추가 작업이 필요하겠죠.

|        Stateful(상태 유지) - 클라이언트 서버 구조에서        |
| :----------------------------------------------------------: |
| <img src="./HTTP.assets/stateful1.png" style="width: 1000px;"><br /><img src="./HTTP.assets/stateful2.png" style="width: 1000px;"> |



그럼 **Stateless(무상태) 방식**을 살펴보겠습니다. 

| Stateless(무상태) - 점원이 바뀌어도 문제 없음!               |
| :----------------------------------------------------------- |
| - 고객: 이 **노트북** 얼마인가요?<br />- **점원A**: 100만원입니다.<br /><br />- 고객: **노트북 2개** 구매하겠습니다.<br />- **점원B**: 노트북 2개는 200만원입니다. **신용카드, 현금** 중에 어떤 걸로 구매하시겠어요?<br /><br />- 고객: **노트북 2개를 신용카드**로 구매하겠습니다.<br />- **점원C**: 200만원 결제 완료되었습니다. |

고객(클라이언트)이 정보를 모두 전달하기 때문에 중간에 다른 점원으로 바뀌어도 문제가 없습니다. 이러한 방법이라면 매장에 고객이 1000명이 몰리더라도 점원 수만 늘리면 걱정이 없습니다.

즉, 클라이언트 요청이 갑자기 증가해도 서버를 대거 투입할 수 있는 것이죠.

|        Stateful(상태 유지) - 클라이언트 서버 구조에서        |
| :----------------------------------------------------------: |
| <img src="./HTTP.assets/stateless1.png" style="width: 1000px;"><br /><img src="./HTTP.assets/stateless2.png" style="width: 1000px;"> |



#### 비연결성(Connectless)

#### HTTP 메시지

#### 단순함, 확장 가능

