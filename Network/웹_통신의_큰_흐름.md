## 웹 통신의 흐름

#### 웹이란 ?

`WWW (world wide web)` 의 약자이며 인터넷으로 연결된 컴퓨터를 통해 정보를 공유할 수 있는 공간을 뜻한다.

흔히들 웹과 인터넷을 통용하여 사용하는데 엄연히 다른 개념이다.

#### 웹 통신

기본적으로 웹 통신은 `HTTP 프로토콜`을 사용하여 통신한다.

통신의 주체를 크게 `Client`와 `Server`로 나눌 수 있다.

- **Client**: 서버에게 정보를 요청하거나 접속하고자 하는 주체

  - ex) 브라우저

- **Server**: 클라이언트에게 정보 혹은 서비스를 제공하는 컴퓨터 (혹은 시스템)

이러한 클라이언트와 서버가 `Request`와 `Response` 를 주고받으며 통신이 일어난다.

#### 웹 통신 세부과정

`https://www.naver.com/` 주소창에 해당 URL을 입력한 뒤 클라이언트에 화면이 렌더링 되기까지 어떤 과정이 있을까?

그 전에, `IP주소`와 `도메인 이름` 그리고 이 둘의 관계에 대해 알아보자.

- IP주소란, 컴퓨터들의 고유 식별번호로 생각하면 된다. IP주소는 `127.0.0.1`과 같은 형태의 숫자로 나타난다.

  > 현재는 .으로 구분된 각 자리에서 0~255를 나타낼 수 있는 32비트의 IPv4 프로토콜을 사용하나, 인터넷 사용자 수 증가로 IP주소 부족 현상이 일어났고 이는 128비트의 IPv6가 등장하는 배경이 되었다.

- 도메인 이름이란, 사람이 쉽게 외울 수 있도록 IP주소를 어떠한 문자로 표현한 것을 의미한다. 즉, 위 URL에서 `naver.com`이 도메인 이름에 해당한다.

> 터미널을 켠 뒤 `host naver.com`을 입력해보자.
> `naver.com` 도메인이 갖는 IP주소를 알 수 있고, 주소창에 해당 IP주소를 입력하면 도메인을 입력했을 때와 같은 결과를 얻는다.

**즉**, 브라우저에 입력된 도메인 이름을 통해 **해당 도메인의 IP주소를 얻은 뒤** 통신을 시작할 수 있다는 것이다.

이러한 `도메인 이름->IP` 과정에서 필요한 도우미 역할을 하는 것이 `DNS`이다.

_다음의 그림과 함께 살펴보자._

![](http://tcpschool.com/lectures/img_webbasic_10.png)

작동 과정은 다음과 같다.

1. 사용자가 **도메인 이름** 입력
2. **DNS**를 통해 도메인 이름과 매핑되는 IP주소 획득
3. **HTTP** 프로토콜을 사용하여 요청 `(=HTTP Request)` 생성
4. **TCP** 프로토콜을 사용하여 **서버의 IP주소 컴퓨터**로 Request 전송
5. 서버가 클라이언트의 **요청**에 대한 **응답** `(=HTTP Response)` 전송
6. 브라우저에 도착한 Response는 **웹페이지를 나타내는 데이터**로 변환되어 브라우저에 나타남.

웹 통신의 물리적인 요소와 관련된 자세한 설명은 아래의 자료에서 볼 수 있다.

- 작성자 윤가영 | [DNS round robin & network flow](./materials/yoongoing_networkflow.pdf)

---

## 질의응답

_질문에 대한 답을 말해보며 공부한 내용을 점검할 수 있으며, 클릭하면 답변 내용을 확인할 수 있습니다._

<details>
<summary>OSI 7계층을 택하면 좋은점이 무엇일까요?</summary> 
<p>

1. 네트워크 통신이 일어나는 과정을 단계별로 살필 수 있기 때문에 문제 원인의 범위를 좁힐 수 있어 효율적이다.
2. 장비 간 호환성을 제공하며 네트워크 장치/컴퓨팅 장치를 만들 때의 참조모델 표준이 될 수 있다.

</p>
</details>

<details>
<summary>많은 직장인들이 아웃룩을 이용하여 회사 메일을 관리하고 있습니다. 아웃룩과 관련된 계층과 프로토콜을 말해주세요.</summary>
<p>

- 계층 : 7계층, Application Layer
- 프로토콜 : SMTP, POP3

아웃룩은 메시지 프로토콜을 사용하기 쉽게하는 응용프로그램이다.

</p>
</details>

<details>
<summary>이전에 저희 회사의 서비스를 제공받는 모든 고객의 pc에서 서비스 중단 이 일어났습니다. OSI 7계층의 관점으로 몇번째 계층의 문제임을 예상할 수 있을까요?</summary>
<p>

한명의 고객이 아닌, “모든 고객의 pc”에서 문제가 생겼으므로, `1계층` 혹은 `3계층`에 문제가 있음을 예상할 수 있다.

</p>
</details>

<details>
<summary>서버에 문제가 생겼는데, Ping Test 시 문제는 없었습니다. 그렇다면 어느 계층에서 문제가 있다는 것을 유추할 수 있나요?</summary>
<p>

Ping Test는 3계층(네트워크 레이어)에 속한다. 즉, 4계층 ~ 7계층 사이에서 문제가 발생한 것으로 유추할 수 있다.

</p>
</details>

<details>
<summary>유튜브와 같은 스트리밍 서비스를 제작해보려합니다. 이때 어떤 프로토콜로 구현할 것인지 관련 계층과 연관지어 말해주세요.</summary>
<p>

의도한 답 : 스트리밍에서는 연속성이 중요하기 때문에 신뢰도는 낮지만 빠른 4계층 transport layer의 `UDP 프로토콜`을 사용하여 구현하겠습니다.

</p>
</details>

---

<details>
<summary>http 프로토콜을 사용하여 개발한 경험이 있다면 말씀해주세요.</summary>
<p>
정해진 답 없음.
</p>
</details>

<details>
<summary>http는 연결성일까요, 비 연결성일까요? 근거를 들어 말해주세요.</summary>
<p>

비연결성이다.

`비연결성`이란 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어 버리는 성질을 말한다.

하지만 다수의 클라이언트와 서버간의 연결상태를 유지하려면 자원이 많이 필요하다. HTTP는 다수의 클라이언트가 웹 서버에 요청하는 방식을 띄므로 연결지속에 필요한 자원을 줄여 더 많은 `Connection` 을 수립하는 것에 중점을 둔다.

</p>
</details>

<details>
<summary>비 연결성의 장점은 무엇인가요?</summary>
<p>

서버에서 다수의 클라이언트와 연결을 유지한다면, 그만큼 리소스가 많이 필요하게 된다. 비연결성이면, 이에 따른 리소스를 줄여 더 많은 연결을 할 수 있다.

</p>
</details>

<details>
<summary>비 연결성의 단점은 무엇이고, 해결법은 무엇인가요?</summary>
<p>

서버가 클라이언트를 기억하고 있지 않아 동일한 클라이언트의 요청에 대해 매번 연결 시도/해제의 작업을 해야하므로 오버헤드가 증가한다.

기본적으로 HTTP Header에는 `Keep-Alive` 속성이 있는데, 이를 통해 연결에 대한 타임아웃을 지정할 수 있다.

연결성외에 클라이언트의 상태 정보를 저장하기 위해서는 `Cookie`, `Token`, `Session` 을 사용하기도한다.

</p>
</details>

<details>
<summary>데이터를 조회하기 위한 용도로 POST가 아닌 GET 방식을 사용하는 이유는 무엇인가요?</summary>

1. 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다. (멱등성)
    - GET 방식은 "가져오는 것"으로, 서버의 데이터나 상태를 변경시키지 않아야 한다.  
      (ex. 게시판의 리스트, 게시글 보기 기능 | 예외. 방문자의 로그 남기기, 글을 읽은 횟수 증가 기능)
    - POST 방식은 "수행하는 것"으로, 서버의 값이나 상태를 바꾸기 위한 용도이다.  
      (ex. 게시판에 글쓰기 기능)
2. 웹에서 모든 리소스는 Link할 수 있는 url을 가지고 있어야 한다.
    - 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.
    - 만일 POST 방식을 사용한다면, 링크의 정보가 Body에 있기 때문에 url만 전달할 수 없으므로 GET 방식을 사용해야 한다. 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.

</details>


<details>
<summary>웹 애플리케이션 제작 시 조회/삭제/수정의 업무를 하려고합니다. 각각을 어떤 방식으로 설계할 것인지 말해주세요.</summary>
<p>

의도한 답 : 조회는 `GET`, 삭제는 `DETELE`, 수정은 `POST`로 설계할 것이다. GET은 조회하기 위한 메서드로 `멱등성`을 만족하기 위해 데이터의 수정이 없어야하며, POST는 서버의 값 혹은 상태를 변경하기 위한 메서드로 수정하기 위해 사용한다. RESTful API에 근거하여 삭제는 DELETE로 설계한다.  

</p>
</details>

---

<details>
<summary>TCP의 특성에 대해서 말씀해주세요. </summary>
<p>

TCP는 `Transfer Control Protocol`로 4계층 Transport Layer에 속하는 프로토콜이다.
1. `3-way Handshaking`을 통해 논리적인 경로의 연결을 수립하고 `4-way Handshaking`을 통해 논리적인 경로의 연결을 해제하는 `Connect Oriented` 즉, 연결지향성 프로토콜이다.
2. 혼잡제어, 흐름제어 기능을 제공한다.
3. `Reliable Data Transfer(=RDT)` 즉, 신뢰성 있는 전송을 지원한다. RDT1.0 ~ RDT3.0 등으로 발전해왔으며 `Go-Back-N`, `Selective Repeat`, `타이머`를 통한 timeout 등 다양한 방식이 있다.
4. HTTP, E-mail, File Transfer 등에 사용된다.
</p>
</details>

<details>
<summary>UDP의 특성에 대해서 말씀해주세요. </summary>
<p>

UDP는 `User Datagram Protocol`로 TCP와 같이 전송계층에 속해있으나 갖는 특징이 조금 다르다.

1. 비연결형, `Connectionless` 프로토콜이다. TCP와 같은 Handshaking 절차가 존재하지 않는다.
2. TCP에서 지원하는 흐름제어, 혼잡제어, 순서보장, 전송보장 기능을 제공하지 않는다.
3. 최소한의 오류검출을 위해 `checksum` 을 활용한다.
4. TCP에 비해 빠른 속도와 적은 부하를 갖기에 `실시간 스트리밍`, `DNS`에 사용하기 적합하다.

</p>
</details>

---

<!-- 4월 3주차 CS면접 주제 : [Network] HTTP와 HTTPS, DNS, 웹 통신 흐름 -->
<!-- 여기 HTTP & HTTPS -->

<details>
<summary>HTTP또는 암호화 되지 않은 프로토콜의 문제점은 무엇이 있나요?</summary>
<p>

1. 평문 통신이기 때문에 도청이 가능하다.

2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다.

3. 완전성을 증명할 수 없기 때문에 변조가 가능하다.

</p>
</details>

<details>
<summary>이러한 문제를 해결하기 위한 다양한 방안이 존재하는데 대표적으로 HTTPS 가 있습니다. HTTPS에 대해 설명 해주시겠어요?</summary>
<p>

HTTPS는 HTTP에 SSL을 덮어 씌운것 과 같다. 원래 HTTP의 통신하는 소켓 부분을 SSL 또는 TLS라는 프로토콜로 대체하는 것이다. HTTP는 원래 TCP와 직접 통신했다면 HTTPS에서는 HTTP와 SSL이 통신하고 SSL과 TCP가 통신하는 방식이라 할 수 있다. SSL을 이용하는 HTTP는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다. 등등

</p>
</details>

<details>
<summary>HTTP 와 HTTPS 중 어떤 프로토콜이 더 많이 사용 된다고 생각하는지와 그 이유에 대해서 말씀해주세요.</summary>
<p>

HTTPS가 보안적인 면에서 뛰어난 만큼 처리해야할 작업이 많아 속도가 떨어져 중요한 데이터 처리 이외에는 HTTP를 사용할 것이라 생각하겠지만 큰 오산이다. 약 10년전 CPU만해도 이러한 작업을 처리하는데 아무런 문제가 없이 사용될만한 실험적 수치를 보였다. 또한 HTTPS 만을 지원하도록 HTTP/2(사실상 HTTP도 지원하지만 개발팀이 그렇게 개발하지 않음)는 다중화와 우선순위를 이용하여 더빠르게 페이지를 로드하는 구글의 네트워크 프로토콜  SPDY를 기반으로 하고 있다. 그래서 HTTP/2를 지원하는 웹이라면 HTTPS 가 속도 조차 더욱 빠르다. 이러한 이유들로 개인정보와 크게 상관없는 사이트들 조차 선택이 아닌 필수로 HTTPS를 사용하고 있다.

[참고링크](https://tech.ssut.me/https-is-faster-than-http/)

</p>
</details>

---

<!-- DNS -->

<details>
<summary>DNS 서버는 무슨 역할을 하나요?</summary>
<p>

DNS 시스템은 ip주소와 도메인 이름의 매핑을 관리합니다. DNS 서버는 ip 주소와 도메인 간의 변환 작업을 수행하며, 사용자가 도메인 이름을 웹 브라우저에 입력하면 해당 사용자를 어떤 서버에 연결할 것인지를 제어하는 역할을 합니다.

</p>
</details>

<details>
<summary>도메인과 ip 주소에 대해서 설명해보세요.</summary>
<p>

인터넷은 서버들을 유일하게 구분할 수 있는 ip 주소를 기본 체계로 이용합니다. 하지만 ip 주소는 숫자로 이루어진 조합이라 인간이 기억하기엔 무리가 있습니다. 따라서 우리는 기억하기 편한 언어 체계의 도메인 이름을 통해 웹 서버에 접속합니다.

</p>
</details>

<details>
<summary>도메인의 구조에 대해서 설명해주세요.</summary>
<p>

도메인은 .(dot) 또는 루트(root)라고 불리는 도메인 이하에 Inverted tree 구조로 구성되어 있습니다. 1단계부터 차례대로 TLD(Top Level Domain), SLD(Second Level Domain), SubDomain이라고 합니다.

</p>
</details>

<details>
<summary>DNS 서버의 Recursive Query 과정을 설명해주세요.</summary>
<p>

로컬 DNS 서버가 여러 DNS 서버를 차례대로 (루트 → com → naver.com DNS 서버) 질의해서 ip 주소를 찾아가는 과정을 말합니다.

</p>
</details>

<details>
<summary>RoundRobin DNS 에 대해 간략하게 설명 해주시겠어요?</summary>
<p>

클라이언트의 웹서버 IP를 요청하는 쿼리를 받을 때마다 여러대의 웹서버를 번갈아가면서 가르쳐즘으로 부화를 분산시키는 로드밸런싱 방법이다.

</p>
</details>

<details>
<summary>Round Robin DNS의 문제점은 무엇이 있을 까요?</summary>
<p>

필요한 서버만큼 공인 IP 주소 필요, 균등하게 분산되지 않을 수 있음(특히 스마트폰의 경우), 서버가 다운되어도 확인 불가 하고, 유저들에게 해당 IP를 제공할 수도 있음.

</p>
</details>

<details>
<summary>이러한 문제점을 해결하기 위한 스케줄링 알고리즘에 대해 설명 해주실 수 있나요?</summary>
<p>

Weighted Round Robin : Round Robin과 같지만 가중치를 더해서 분산비율을 변경한다. 가중치가 큰 서버일 수록 자주 선택되므로 처리능력이 높은 서버를 가중치를 높게 설정한다.

Least Connection : 접속수가 가장 적은 서버를 선택한다.

</p>
</details>

---

<!-- 웹 통신 흐름 -->

<details>
<summary>인터넷에 <code>www.naver.com</code>을 쳤을 때, 브라우저의 렌더링 과정에 대해 설명해주세요.</summary>
<p>

1. 로컬 DNS 서버에게 `www.naver.com`에 해당하는 ip 주소가 있는지 물어본다. 있다면 바로 해당 ip로 받아온다.
2. 없다면, 루트 DNS 서버에 물어본다. 있다면 바로 해당 ip로 받아온다.
3. 없다면, `.com`을 관리하는 DNS 서버에 물어본다. 있다면 바로 해당 ip로 받아온다.
4. 없다면, `naver.com`을 관리하는 DNS 서버에 물어본다. 있다면 바로 해당 ip로 받아온다.
5. 목적지의 ip를 알게 되었다. TCP 통신을 통해 소켓을 개방한다. (웹 브라우저 ⇔ 서버 : TCP 3 way handshaking 방식을 통한 커넥션 생성)
6. HTTP 프로토콜로 요청한다.
7. 라우팅 중 프록시 서버를 만난다면, 웹 캐시에 저장된 정보를 response 받는다.
8. 프록시 서버를 만나지 못해 `www.naver.com`을 서빙하는 서버까지 간다면 서버에서 요청에 맞는 데이터를 response로 전송한다.
9. 브라우저의 loader가 해당 response를 다운로드할지 말지 결정한다.
10. 브라우저의 웹 엔진이 다운로드한 .html 파일을 파싱하여 DOM 트리를 결정한다.
11. .html 파싱 중 script 태그를 만나면 파싱을 중단한다.
12. script 태그에 있는 자원을 다운로드하여 처리가 완료되면 다시 파싱을 재개한다.
13. css parser가 .css 파일을 파싱하여 스타일 규칙을 DOM 트리에 추가하여 렌더 트리를 만든다.
14. 렌더 트리를 기반으로 브라우저의 크기에 따라 각 노드들이 크기를 결정한다.
15. 페인트한다. (렌더링 엔진이 배치를 시작한다.)

</p>
</details>

<details>
<summary>브라우저가 전송한 request 메시지를 웹 서버까지 전송하고 그 응답을 받기까지의 과정을 설명해주세요.</summary>
<p>

> 브라우저 → 프로토콜 스택 → LAN 어댑터 → 스위칭 허브 → 라우터 → 인터넷 → 웹 서버 LAN → 웹 서버 → 웹 서버 어플리케이션 → 응답은 왔던 길 그대로 돌아감

1. 운영체제에 내장된 네트워크 제어용 소프트웨어인 프로토콜 스택이 브라우저로부터 메시지를 받습니다.
2. 브라우저로부터 받은 메시지를 패킷 속에 저장하고, 수신처 주소 등의 제어 정보를 덧붙여 패킷을 LAN 어댑터에 넘깁니다.
3. LAN 어댑터는 다음 Hop의 Mac 주소를 붙인 프레임을 전기 신호로 변환시키고 신호를 LAN 케이블에 송출시킵니다.
4. LAN 어댑터가 송신한 프레임은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착합니다.
5. 라우터는 패킷을 프로바이더(통신사)에게 전달합니다.
6. 패킷은 인터넷의 입구에 있는 액세스 회선(통신 회선)에 의해 POP(Point Of Presence, 통신사용 라우터)까지 운반됩니다.
7. 패킷은 POP를 거쳐 인터넷의 핵심부로 들어가 목적지를 향해 흘러갑니다.
8. 패킷은 인터넷 핵심부를 통과하여 목적지 웹 서버측의 LAN에 도착합니다.
9. 기다리고 있던 방화벽이 도착한 패킷을 검사합니다. 또한 캐시 서버가 웹 서버까지 갈지 말지를 판단합니다.
10. 패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 웹 서버 어플리케이션에 넘깁니다.
11. 메시지를 받은 웹 서버 어플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송합니다. 응답 메시지는 왔던 방식 그대로 돌아갑니다.

</p>
</details>

<details>
<summary>프로토콜 스택은 어떤 역할을 하나요?</summary>
<p>

통신 중 오류가 발생했을 때 제어 정보를 사용하여 고쳐보내거나, 각종 상황을 조절하는 등 네트워크 세계의 비서와 같은 역할을 합니다.

</p>
</details>

<details>
<summary>프록시 서버는 어떤 기능을 하나요?</summary>
<p>

프록시 서버는 클라이언트로부터 요청된 내용들을 캐시에 저장하고 다음에 같은 요청이 들어온다면 캐시에 저장된 정보를 제공합니다. 이로써 전송 시간을 줄일 수 있습니다.

</p>
</details>

<details>
<summary>그럼 두 번 이상 요청된 내용은 프록시 서버 캐시로부터 다운로드받게 될텐데 페이지의 값이 바뀐다면 어떻게 처리할 수 있나요?</summary>
<p>

최초 요청 시 실제 서버에서 캐시 만료 기한을 설정해서 프록시 서버로 보내면 됩니다. 프록시 서버로 사용자가 요청을 했을 때 요청한 시각이 만료 기한이 이내라면 프록시 서버에서 다운로드를 하고, 그렇지 않다면 실제 서버로 다시 요청합니다.

</p>
</details>

<details>
<summary>서로 다른 프로토콜을 사용하는 두 네트워크를 연결하기 위한 방법은 무엇이 있을 까요?</summary>
<p>

게이트웨이란 현재 사용자가 위치한 네트워크에서 다른 네트워크로 이동하기 위해 반드시 거쳐야하는 거점을 의미한다. 두 컴퓨터 네트워크 상에서 서로 연결되기 위해서는 동일한 통신 프로토콜을 사용해야 한다. 따라서 프로토콜이 다른 네트워크 상의 컴퓨터와 두 프로토콜을 적절히 변환해 주는 변환기가 필요한데, 게이트웨이가 바로 이러한 변환기 역할을 한다.

</p>
</details>

<details>
<summary>CORS 문제가 무엇이고 경험해본적 있는가요?</summary>
<p>

CORS는 Cross Origin Resource Sharing의 약자로 클라이언트가 도메인 및 포트가 다른 서버로  요청했을 때 브라우저가 보안상의 이유로 API를 차단하는 문제이다.  예로 들면 로컬에서 클라이언트는 3000 포트로 서버는 10000 포트로 서버를 띄웠을때 또는 로컬 서버에서 다른 서버로 호출할 때 발생하게 된다.

</p>
</details>
