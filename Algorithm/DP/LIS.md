# LIS (Longest Increasing Subsequence)

관련 문제 : https://www.acmicpc.net/problem/12015  Gold 2 ㅎㅎ

> 최장 증가 부분 수열

- 배열 3 5 7 9 2 1 4 8
- 3 5 7 8 or 3 5 7 9이 길이 4로 최장 증가 부분 수열이다.



### ○ 첫 번째 알고리즘 : O(N^2)

의미없음

### ○ 두 번째 알고리즘 : O(N log N)

​	(log N은 자리를 찾는 시간복잡도)

> 1.  arr[i] 에서 i = 0부터 i = N-1까지 배열을 탐색
> 2. 매 원소가 들어갈 자리를 탐색한 후 배열에 넣는다.
>    - 마지막 요소보다 크다면 추가
>    - 작다면 자리를 대체 (덮어씀)
>      - 길이를 유지함
>      - 길이만을 구할 수 있음.

ex1)

#### 배열 [10, 20, 10, 30, 20, 50]

- i = 0
  - [10]
- i = 1
  - [10, 20]
- i = 2
  - [10, 20] (10을 덮어씀)
- i = 3
  - [10, 20, 30]
- i = 4
  - [10, 20, 30] (20을 덮어씀)
- i = 5
  - [10, 20, 30, 50]
- 배열의 길이인 4가 정답이 됨

ex2)

#### 배열 [5, 2, 4, 3, 7, 5, 1, 6, 7]

[5]

[2]     # 2는 마지막 원소 5보다 작으므로, 5를 덮어씀

[2, 4]    

[3, 4]      # 3은 마지막 원소 4보다 작고, [ , 2] 사이값이므로 2를 덮어씀

[3, 4, 7]

[3, 4, 5]      # 5는 [4, 7] 사이값이므로 7을 덮어씀 38 3 4 5 6 2 5 67  6 7

[1, 4, 5]      # 1은 [ , 3] 사이값이므로  3을 덮어씀

[1, 4, 5, 6] 

[1, 4, 5, 6, 7]

답 : 5

```python
import bisect

N = int(input())
arr = list(map(int,input().split()))

LIS = [arr[0]]
for i in range(1,N):
    if (arr[i]>LIS[-1]):
        LIS.append(arr[i])
    else:
        idx = bisect.bisect_left(LIS, arr[i]) # bisect.bisect_left(arr,x) : 정렬되어있다면 arr의 x가 들어갈 인덱스를 binary Search를 통해 반환
        LIS[idx] = arr[i]
print(len(LIS))
```



- 위 과정은 LIS의 길이만을 구할 수 있음. 원소들을 알고싶다면, ↓



### ○LIS 구하기! 

- LIS에 들어가는 값의 인덱스를 기록한다.

#### 배열 [5, 2, 4, 3, 7, 5, 1, 6, 7]

[5]                                            -> 1

[2]     # 2는 마지막 원소 5보다 작으므로, 5를 덮어씀    -> 1

[2, 4]                                                                                    -> 2

[3, 4]      # 3은 마지막 원소 4보다 작고, [ , 2] 사이값이므로 2를 덮어씀  -> 2

[3, 4, 7]                                                                                                -> 3

[3, 4, 5]      # 5는 [4, 7] 사이값이므로 7을 덮어씀                           -> 3

[1, 4, 5]      # 1은 [ , 3] 사이값이므로  3을 덮어씀                           -> 1

[1, 4, 5, 6]                                                                            -> 4

[1, 4, 5, 6, 7]                                                                        -> 5

답 : 5

​                        [5, 2, 4, 3, 7, 5, 1, 6, 7]

-> 뒤의 숫자 : [1, 1, 2, 2, 3, 3, 1, 4, 5]

5~1까지의 가장 오른쪽에 있는 인덱스를 나타내면, [9, 8, 6, 4, 2] 가 되므로[7, 6, 5, 3, 2]

역순으로 나타내면 LIS는 [2, 3, 5, 6, 7]이 된다.





### 참조

https://seohyun0120.tistory.com/entry/%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4LIS-%EC%99%84%EC%A0%84-%EC%A0%95%EB%B3%B5-%EB%B0%B1%EC%A4%80-%ED%8C%8C%EC%9D%B4%EC%8D%AC

